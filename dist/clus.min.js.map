{"version":3,"file":null,"sources":["../src/core/utils.js","../src/core/extend.js","../src/core/dom.js","../src/core/core.js","../src/core/init.js","../src/sizzle/sizzle.js","../src/sizzle/init.js","../src/index.js"],"sourcesContent":["//\n// utils.js\n//\n\nexport function trim(text) {\n    const rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n    return text == null ? '' : `${text}`.replace(rtrim, '');\n}\n\nexport function type(object) {\n    let class2type = {},\n        type = class2type.toString.call(object),\n        typeString = 'Boolean Number String Function Array Date RegExp Object Error Symbol';\n\n    if (object == null) {\n        return object + '';\n    }\n\n    typeString.split(' ').forEach((type) => {\n        class2type[`[object ${type}]`] = type.toLowerCase();\n    });\n\n    return (\n        typeof object === 'object' ||\n        typeof object === 'function'\n        ?\n        class2type[type] || 'object'\n        :\n        typeof object\n    );\n}\n\nexport function isPlainObject(object) {\n    let proto,\n        ctor,\n        class2type = {},\n        toString = class2type.toString, // Object.prototype.toString\n        hasOwn = class2type.hasOwnProperty,\n        fnToString = hasOwn.toString, // Object.toString/Function.toString\n        ObjectFunctionString = fnToString.call( Object ); // 'function Object() { [native code] }'\n\n    if (!object || toString.call(object) !== '[object Object]') {\n        return false;\n    }\n\n    // According to the object created by `Object.create(null)` is no `prototype`\n    proto = Object.getPrototypeOf(object);\n    if (!proto) {\n        return true;\n    }\n\n    ctor = hasOwn.call(proto, 'constructor') && proto.constructor;\n    return typeof ctor === 'function' && fnToString.call( ctor ) === ObjectFunctionString;\n}\n\nexport function merge(first, second) {\n    let length = +second.length,\n\t\tj = 0,\n\t\ti = first.length;\n\n\tfor ( ; j < length; j++ ) {\n\t\tfirst[ i++ ] = second[ j ];\n\t}\n\n\tfirst.length = i;\n\n\treturn first;\n}\n","//\n// extend.js\n//\n\nimport { isPlainObject, type } from './utils.js';\n\nexport default function extend() {\n    let options, name, clone, copy, source, copyIsArray,\n        target = arguments[0] || {},\n        i = 1,\n        length = arguments.length,\n        deep = false;\n\n    if (typeof target === 'boolean') {\n        deep = target;\n        target = arguments[i] || {};\n        i++;\n    }\n\n    if (typeof target !== 'object' && type(target) !== 'function') {\n        target = {};\n    }\n\n    if (i === length) {\n        target = this;\n        i--;\n    }\n\n    for (; i < length; i++) {\n        //\n        if ((options = arguments[i]) !== null) {\n            // for in source object\n            for (name in options) {\n\n                source = target[name];\n                copy = options[name];\n\n                if (target == copy) {\n                    continue;\n                }\n\n                // deep clone\n                if (deep && copy && (isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {\n                    // if copy is array\n                    if (copyIsArray) {\n                        copyIsArray = false;\n                        // if is not array, set it to array\n                        clone = source && Array.isArray(source) ? source : [];\n                    } else {\n                        // if copy is not a object, set it to object\n                        clone = source && isPlainObject(source) ? source : {};\n                    }\n\n                    target[name] = extend(deep, clone, copy);\n                } else if (copy !== undefined) {\n                    target[name] = copy;\n                }\n            }\n        }\n    }\n\n    return target;\n}\n","//\n// classes.js\n//\n\nconst rnotwhite = /\\S+/g;\nconst rclass = /[\\t\\r\\n\\f]/g;\n\nfunction getClass(el) {\n    return el.getAttribute && el.getAttribute('class') || '';\n}\n\nexport default {\n    addClass: function addClass(cls) {\n        let classes, clazz, el, cur, curValue, finalValue, j, i = 0;\n\n        if (typeof cls === 'string' && cls) {\n            classes = cls.match(rnotwhite) || [];\n\n            while((el = this[i++])) {\n                curValue = getClass(el);\n                cur = (el.nodeType === 1) && ` ${curValue} `.replace(rclass, ' ');\n\n                if (cur) {\n                    j = 0;\n\n                    while((clazz = classes[j++])) {\n                        // to determine whether the class that to add has already existed\n                        if (cur.indexOf(` ${clazz} `) == -1) {\n                            cur += clazz + ' ';\n                        }\n                        finalValue = Clus.trim(cur);\n                        if ( curValue !== finalValue ) {\n                            el.setAttribute('class', finalValue);\n                        }\n                    }\n                }\n            }\n        }\n\n        return this;\n    },\n    removeClass: function removeClass(cls) {\n        let classes, clazz, el, cur, curValue, finalValue, j, i = 0;\n\n        if (!arguments.length) {\n            return;\n        }\n\n        if (typeof cls === 'string' && cls) {\n            classes = cls.match(rnotwhite) || [];\n\n            while((el = this[i++])) {\n                curValue = getClass(el);\n                cur = (el.nodeType === 1) && ` ${curValue} `.replace(rclass, ' ');\n\n                if (cur) {\n                    j = 0;\n\n                    while((clazz = classes[j++])) {\n                        // to determine whether the class that to add has already existed\n                        if (cur.indexOf(` ${clazz} `) !== -1) {\n                            cur = cur.replace(` ${clazz} `, ' ');\n                        }\n                        finalValue = Clus.trim(cur);\n                        if ( curValue !== finalValue ) {\n                            el.setAttribute('class', finalValue);\n                        }\n                    }\n                }\n            }\n        }\n\n        return this;\n    },\n    hasClass: function hasClass(cls) {\n        let el, i = 0, className = ` ${cls} `;\n\n        while((el = this[i++])) {\n            if (\n                el.nodeType === 1\n                &&\n                ` ${getClass(el)} `.replace(rclass, ' ').indexOf(className) !== -1\n            ) {\n                return true;\n            }\n        }\n\n        return false;\n    },\n    toggleClass: function toggleClass(cls) {\n        let el, i = 0;\n\n        while((el = this[i++])) {\n            if (this.hasClass(cls)) {\n                this.removeClass(cls);\n                return this;\n            } else {\n                this.addClass(cls);\n                return this;\n            }\n        }\n    },\n};\n","//\n// Core.js\n//\n\nimport extend from './extend.js';\nimport { merge, trim } from './utils.js';\nimport DOM from './dom.js';\n\nexport default function Clus(selector, context) {\n    return new Clus.fn.init(selector, context);\n}\n\nClus.fn = Clus.prototype = {\n    contructor: Clus,\n    length: 0,\n};\n\nClus.extend = Clus.fn.extend = extend;\n\nClus.extend({\n    merge,\n    trim,\n});\n\n// ============\n// extend selector\n// ============\n\nClus.fn.extend({\n    pushStack: function (els) {\n        let ret = merge(this.contructor(), els);\n        ret.prevObject = this;\n        return ret;\n    },\n    find: function (selector) {\n        let i = 0,\n            len = this.length,\n            self = this,\n            ret = this.pushStack([]);\n\n        for (; i < len; i++) {\n            Clus.find(selector, self[ i ], ret);\n        }\n\n        return ret;\n    },\n    end: function end() {\n        return this.prevObject || this.constructor();\n    },\n    eq: function eq(i) {\n        let len = this.length,\n            j = +i + ( i < 0 ? len : 0 ); // reverse find\n        return this.pushStack(j >= 0 && j < len ? [this[j]] : []);\n    },\n    first: function first() {\n        return this.eq(0);\n    },\n    last: function last() {\n        return this.eq(-1);\n    },\n});\n\n// ============\n// extend DOM methods\n// ============\nClus.fn.extend(DOM);\n\nwindow.Clus = window.C = window.$$ = Clus;\n","//\n// init.js\n//\n\nexport default function init(Clus) {\n    Clus.fn.init = function (selector, context, root) {\n        if (!selector) {\n            return;\n        } else {\n            let els = Clus.find(selector);\n            if (els.length) {\n                Clus.merge(this, els);\n            }\n            return this;\n        }\n    };\n    Clus.fn.init.prototype = Clus.fn;\n}\n","/*!\n * Sizzle CSS Selector Engine v@VERSION\n * https://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: @DATE\n */\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it's faster than native\n\t// https://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\n\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\"*\\\\]\",\n\n\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\n\t// CSS escapes\n\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// CSS string/identifier serialization\n\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\tfcssescape = function( ch, asCodePoint ) {\n\t\tif ( asCodePoint ) {\n\n\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\tif ( ch === \"\\0\" ) {\n\t\t\t\treturn \"\\uFFFD\";\n\t\t\t}\n\n\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\treturn ch.slice( 0, -1 ) + \"\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n\t\t}\n\n\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\treturn \"\\\\\" + ch;\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t},\n\n\tinDisabledFieldset = addCombinator(\n\t\tfunction( elem ) {\n\t\t\treturn elem.disabled === true && elem.nodeName.toLowerCase() === \"fieldset\";\n\t\t},\n\t\t{ dir: \"parentNode\", next: \"legend\" }\n\t);\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar m, i, elem, nid, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\n\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( (m = match[1]) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( (elem = context.getElementById( m )) ) {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && (elem = newContext.getElementById( m )) &&\n\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName &&\n\t\t\t\t\tcontext.getElementsByClassName ) {\n\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( support.qsa &&\n\t\t\t\t!compilerCache[ selector + \" \" ] &&\n\t\t\t\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\n\t\t\t\tif ( nodeType !== 1 ) {\n\t\t\t\t\tnewContext = context;\n\t\t\t\t\tnewSelector = selector;\n\n\t\t\t\t// qSA looks outside Element context, which is not what we want\n\t\t\t\t// Thanks to Andrew Dupont for this workaround technique\n\t\t\t\t// Support: IE <=8\n\t\t\t\t// Exclude object elements\n\t\t\t\t} else if ( context.nodeName.toLowerCase() !== \"object\" ) {\n\n\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\tif ( (nid = context.getAttribute( \"id\" )) ) {\n\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.setAttribute( \"id\", (nid = expando) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[i] = \"#\" + nid + \" \" + toSelector( groups[i] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( \",\" );\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\t\t\t\t}\n\n\t\t\t\tif ( newSelector ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + \" \" ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result\n */\nfunction assert( fn ) {\n\tvar el = document.createElement(\"fieldset\");\n\n\ttry {\n\t\treturn !!fn( el );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( el.parentNode ) {\n\t\t\tel.parentNode.removeChild( el );\n\t\t}\n\t\t// release memory in IE\n\t\tel = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = arr.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\ta.sourceIndex - b.sourceIndex;\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled\n */\nfunction createDisabledPseudo( disabled ) {\n\n\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\treturn function( elem ) {\n\n\t\t// Only certain elements can match :enabled or :disabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\tif ( \"form\" in elem ) {\n\n\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t// * option elements in a disabled optgroup\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t// All such elements have a \"form\" property.\n\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\n\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\tif ( \"label\" in elem ) {\n\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\t\tinDisabledFieldset( elem ) === disabled;\n\t\t\t}\n\n\t\t\treturn elem.disabled === disabled;\n\n\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n\t\t// even exist on them, let alone have a boolean value.\n\t\t} else if ( \"label\" in elem ) {\n\t\t\treturn elem.disabled === disabled;\n\t\t}\n\n\t\t// Remaining elements are neither :enabled nor :disabled\n\t\treturn false;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, subWindow,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocElem = document.documentElement;\n\tdocumentIsHTML = !isXML( document );\n\n\t// Support: IE 9-11, Edge\n\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\tif ( preferredDoc !== document &&\n\t\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\n\n\t\t// Support: IE 11, Edge\n\t\tif ( subWindow.addEventListener ) {\n\t\t\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\n\n\t\t// Support: IE 9 - 10 only\n\t\t} else if ( subWindow.attachEvent ) {\n\t\t\tsubWindow.attachEvent( \"onunload\", unloadHandler );\n\t\t}\n\t}\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( el ) {\n\t\tel.className = \"i\";\n\t\treturn !el.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( el ) {\n\t\tel.appendChild( document.createComment(\"\") );\n\t\treturn !el.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programmatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( el ) {\n\t\tdocElem.appendChild( el ).id = expando;\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t});\n\n\t// ID filter and find\n\tif ( support.getById ) {\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t}\n\t\t};\n\t} else {\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n\t\t\t\t\telem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\n\t\t// Support: IE 6 - 7 only\n\t\t// getElementById is not reliable as a find shortcut\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar node, i, elems,\n\t\t\t\t\telem = context.getElementById( id );\n\n\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile ( (elem = elems[i++]) ) {\n\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn [];\n\t\t\t}\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See https://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( el ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( el ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( el.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !el.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !el.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( el ) {\n\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" +\n\t\t\t\t\"<select disabled='disabled'><option/></select>\";\n\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = document.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( el.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( el.querySelectorAll(\":enabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n\t\t\tdocElem.appendChild( el ).disabled = true;\n\t\t\tif ( el.querySelectorAll(\":disabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tel.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( el ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( el, \"*\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( el, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully self-exclusive\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === document ? -1 :\n\t\t\t\tb === document ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t!compilerCache[ expr + \" \" ] &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.escape = function( sel ) {\n\treturn (sel + \"\").replace( rcssescape, fcssescape );\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": createDisabledPseudo( false ),\n\t\t\"disabled\": createDisabledPseudo( true ),\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tskip = combinator.next,\n\t\tkey = skip || dir,\n\t\tcheckNonElements = base && key === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\n\n\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t} else if ( (oldCache = uniqueCache[ key ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\tif ( !context && elem.ownerDocument !== document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( el ) {\n\t// Should return 1, but returns 4 (following)\n\treturn el.compareDocumentPosition( document.createElement(\"fieldset\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( el ) {\n\tel.innerHTML = \"<a href='#'></a>\";\n\treturn el.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( el ) {\n\tel.innerHTML = \"<input/>\";\n\tel.firstChild.setAttribute( \"value\", \"\" );\n\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( el ) {\n\treturn el.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\n// EXPOSE\nvar _sizzle = window.Sizzle;\n\nSizzle.noConflict = function() {\n\tif ( window.Sizzle === Sizzle ) {\n\t\twindow.Sizzle = _sizzle;\n\t}\n\n\treturn Sizzle;\n};\n\nexport default Sizzle;\n","//\n// sizzle initialize\n//\n\nimport Sizzle from './sizzle.js';\n\nexport default function initSizzle(Clus) {\n    Clus.find = Sizzle;\n}\n","// @flow\n\nimport Clus from './core/core.js';\nimport init from './core/init.js';\nimport initSizzle from './sizzle/init.js';\n\ninit(Clus);\ninitSizzle(Clus);\n"],"names":["trim","text","rtrim","replace","type","object","class2type","toString","call","typeString","split","forEach","toLowerCase","isPlainObject","proto","ctor","hasOwnProperty","fnToString","hasOwn","Object","getPrototypeOf","constructor","ObjectFunctionString","merge","first","second","length","j","i","extend","options","name","clone","copy","source","copyIsArray","target","arguments","deep","this","Array","isArray","undefined","getClass","el","getAttribute","Clus","selector","context","fn","init","root","els","find","prototype","Sizzle","results","seed","m","elem","nid","match","groups","newSelector","newContext","ownerDocument","nodeType","preferredDoc","document","documentIsHTML","rquickExpr","exec","getElementById","id","push","contains","apply","getElementsByTagName","support","getElementsByClassName","qsa","compilerCache","rbuggyQSA","test","nodeName","rcssescape","fcssescape","setAttribute","expando","tokenize","toSelector","join","rsibling","testContext","parentNode","querySelectorAll","qsaError","removeAttribute","select","createCache","cache","key","value","keys","Expr","cacheLength","shift","markFunction","assert","createElement","e","removeChild","addHandle","attrs","handler","arr","attrHandle","siblingCheck","a","b","cur","diff","sourceIndex","nextSibling","createInputPseudo","createButtonPseudo","createDisabledPseudo","disabled","isDisabled","inDisabledFieldset","createPositionalPseudo","argument","matches","matchIndexes","setFilters","tokens","len","addCombinator","matcher","combinator","base","dir","skip","next","checkNonElements","doneName","done","xml","oldCache","uniqueCache","outerCache","newCache","dirruns","uniqueID","elementMatcher","matchers","multipleContexts","contexts","condense","unmatched","map","filter","newUnmatched","mapped","setMatcher","preFilter","postFilter","postFinder","postSelector","temp","preMap","postMap","preexisting","elems","matcherOut","matcherIn","indexOf","splice","matcherFromTokens","checkContext","leadingRelative","relative","implicitRelative","matchAnyContext","ret","outermostContext","matchContext","slice","concat","matcherFromGroupMatchers","elementMatchers","setMatchers","bySet","byElement","superMatcher","outermost","matchedCount","setMatched","contextBackup","Math","random","dirrunsUnique","pop","uniqueSort","initSizzle","rnotwhite","rclass","cls","classes","clazz","curValue","finalValue","className","hasClass","removeClass","addClass","contructor","prevObject","self","pushStack","eq","DOM","window","C","$$","getText","isXML","compile","sortInput","hasDuplicate","setDocument","docElem","rbuggyMatches","Date","classCache","tokenCache","sortOrder","push_native","list","booleans","whitespace","identifier","attributes","pseudos","rwhitespace","RegExp","rcomma","rcombinators","rattributeQuotes","rpseudo","ridentifier","matchExpr","rinputs","rheader","rnative","runescape","funescape","_","escaped","escapedWhitespace","high","fromCharCode","ch","asCodePoint","charCodeAt","unloadHandler","childNodes","documentElement","node","hasCompare","subWindow","doc","defaultView","top","addEventListener","attachEvent","appendChild","createComment","getById","getElementsByName","attrId","getAttributeNode","tag","tmp","innerHTML","input","matchesSelector","webkitMatchesSelector","mozMatchesSelector","oMatchesSelector","msMatchesSelector","disconnectedMatch","compareDocumentPosition","adown","bup","compare","sortDetached","aup","ap","bp","unshift","expr","elements","attr","val","specified","escape","sel","error","msg","Error","duplicates","detectDuplicates","sortStable","sort","textContent","firstChild","nodeValue","selectors","excess","unquoted","nodeNameSelector","pattern","operator","check","result","what","last","simple","forward","ofType","nodeIndex","start","parent","useCache","lastChild","pseudo","args","idx","matched","innerText","lang","elemLang","hash","location","activeElement","hasFocus","href","tabIndex","checked","selected","selectedIndex","radio","checkbox","file","password","image","submit","reset","filters","parseOnly","soFar","preFilters","cached","token","compiled","defaultValue","_sizzle","noConflict"],"mappings":"gKAIO,SAASA,GAAKC,MACXC,GAAQ,2CACC,OAARD,EAAe,OAAQA,GAAOE,QAAQD,EAAO,IAGjD,QAASE,GAAKC,MACbC,MACAF,EAAOE,EAAWC,SAASC,KAAKH,GAChCI,EAAa,6EAEH,OAAVJ,EACOA,EAAS,MAGTK,MAAM,KAAKC,QAAQ,SAACP,gBACLA,OAAWA,EAAKQ,gBAIpB,+BAAXP,iBAAAA,KACW,kBAAXA,GAEPC,EAAWF,IAAS,4BAEbC,iBAAAA,IAIR,QAASQ,GAAcR,MACtBS,UACAC,SACAT,KACAC,EAAWD,EAAWC,WACbD,EAAWU,eACpBC,EAAaC,EAAOX,WACGU,EAAWT,KAAMW,iBAEvCd,GAAoC,oBAA1BE,EAASC,KAAKH,UAKrBc,OAAOC,eAAef,QAKvBa,EAAOV,KAAKM,EAAO,gBAAkBA,EAAMO,YAC3B,kBAATN,IAAuBE,EAAWT,KAAMO,KAAWO,IAG9D,QAASC,GAAMC,EAAOC,UACrBC,IAAUD,EAAOC,OACvBC,EAAI,EACJC,EAAIJ,EAAME,OAEHC,EAAID,EAAQC,MACZC,KAAQH,EAAQE,YAGlBD,OAASE,EAERJ,EC5DO,QAASK,QAChBC,UAASC,SAAMC,SAAOC,SAAMC,SAAQC,SACpCC,EAASC,UAAU,OACnBT,EAAI,EACJF,EAASW,UAAUX,OACnBY,GAAO,MAEW,iBAAXF,OACAA,IACEC,UAAUT,YAID,+BAAXQ,iBAAAA,KAAwC,aAAjBhC,EAAKgC,WAInCR,IAAMF,MACGa,UAINX,EAAIF,EAAQE,OAEkB,QAA5BE,EAAUO,UAAUT,QAEhBG,IAAQD,KAEAM,EAAOL,KACTD,EAAQC,GAEXK,GAAUH,IAKVK,GAAQL,IAASpB,EAAcoB,KAAUE,EAAcK,MAAMC,QAAQR,MAEjEE,MACc,IAEND,GAAUM,MAAMC,QAAQP,GAAUA,QAGlCA,GAAUrB,EAAcqB,GAAUA,OAGvCH,GAAQF,EAAOS,EAAMN,EAAOC,IACnBS,SAATT,MACAF,GAAQE,UAMxBG,GCtDX,QAASO,GAASC,SACPA,GAAGC,cAAgBD,EAAGC,aAAa,UAAY,GCA3C,QAASC,GAAKC,EAAUC,SAC5B,IAAIF,GAAKG,GAAGC,KAAKH,EAAUC,GCLvB,QAASE,GAAKJ,KACpBG,GAAGC,KAAO,SAAUH,EAAUC,EAASG,MACnCJ,EAEE,IACCK,GAAMN,EAAKO,KAAKN,SAChBK,GAAI1B,UACCH,MAAMgB,KAAMa,GAEdb,SAGVU,GAAGC,KAAKI,UAAYR,EAAKG,GCsMlC,QAASM,GAAQR,EAAUC,EAASQ,EAASC,MACxCC,GAAG9B,EAAG+B,EAAMC,EAAKC,EAAOC,EAAQC,EACnCC,EAAahB,GAAWA,EAAQiB,gBAGrBjB,EAAUA,EAAQkB,SAAW,OAE/BV,MAGe,gBAAbT,KAA0BA,GACxB,IAAbmB,GAA+B,IAAbA,GAA+B,KAAbA,QAE7BV,OAIFC,KAEET,EAAUA,EAAQiB,eAAiBjB,EAAUmB,KAAmBC,KACzDpB,KAEJA,GAAWoB,EAEhBC,GAAiB,IAIH,KAAbH,IAAoBL,EAAQS,GAAWC,KAAMxB,OAG3CW,EAAIG,EAAM,OAGG,IAAbK,EAAiB,MACfP,EAAOX,EAAQwB,eAAgBd,UAU7BF,MALFG,EAAKc,KAAOf,WACRgB,KAAMf,GACPH,UAYJQ,IAAeL,EAAOK,EAAWQ,eAAgBd,KACrDiB,EAAU3B,EAASW,IACnBA,EAAKc,KAAOf,WAEJgB,KAAMf,GACPH,MAKH,CAAA,GAAKK,EAAM,aACZe,MAAOpB,EAASR,EAAQ6B,qBAAsB9B,IAC5CS,CAGD,KAAME,EAAIG,EAAM,KAAOiB,EAAQC,wBACrC/B,EAAQ+B,iCAEHH,MAAOpB,EAASR,EAAQ+B,uBAAwBrB,IAC9CF,KAKJsB,EAAQE,MACXC,GAAelC,EAAW,QACzBmC,IAAcA,EAAUC,KAAMpC,IAAc,IAE5B,IAAbmB,IACSlB,IACCD,MAMR,IAAwC,WAAnCC,EAAQoC,SAASxE,cAA6B,MAGnDgD,EAAMZ,EAAQH,aAAc,SAC3Be,EAAIzD,QAASkF,GAAYC,MAEvBC,aAAc,KAAO3B,EAAM4B,KAI3BC,EAAU1C,KACfe,EAAOpC,OACHE,OACAA,GAAK,IAAMgC,EAAM,IAAM8B,EAAY5B,EAAOlC,MAEpCkC,EAAO6B,KAAM,OAGdC,GAAST,KAAMpC,IAAc8C,EAAa7C,EAAQ8C,aAC9D9C,KAGGe,gBAEEa,MAAOpB,EACXQ,EAAW+B,iBAAkBhC,IAEvBP,EACN,MAAQwC,YAEJpC,IAAQ4B,KACJS,gBAAiB,cASxBC,GAAQnD,EAAS5C,QAASD,GAAO,MAAQ8C,EAASQ,EAASC,GASnE,QAAS0C,aAGCC,GAAOC,EAAKC,SAEfC,GAAK7B,KAAM2B,EAAM,KAAQG,EAAKC,mBAE3BL,GAAOG,EAAKG,SAEZN,EAAOC,EAAM,KAAQC,KAR1BC,YAUGH,GAOR,QAASO,GAAc1D,YAClBuC,IAAY,EACTvC,EAOR,QAAS2D,GAAQ3D,MACZL,GAAKwB,EAASyC,cAAc,wBAGtB5D,EAAIL,GACZ,MAAOkE,UACD,UAGFlE,EAAGkD,cACJA,WAAWiB,YAAanE,KAGvB,MASP,QAASoE,GAAWC,EAAOC,UACtBC,GAAMF,EAAMvG,MAAM,KACrBkB,EAAIuF,EAAIzF,OAEDE,OACFwF,WAAYD,EAAIvF,IAAOsF,EAU9B,QAASG,GAAcC,EAAGC,MACrBC,GAAMD,GAAKD,EACdG,EAAOD,GAAsB,IAAfF,EAAEpD,UAAiC,IAAfqD,EAAErD,UACnCoD,EAAEI,YAAcH,EAAEG,eAGfD,QACGA,MAIHD,OACKA,EAAMA,EAAIG,gBACbH,IAAQD,SACL,QAKHD,GAAI,GAAI,EAOhB,QAASM,GAAmBxH,SACpB,UAAUuD,MACZ5B,GAAO4B,EAAKyB,SAASxE,oBACT,UAATmB,GAAoB4B,EAAKvD,OAASA,GAQ3C,QAASyH,GAAoBzH,SACrB,UAAUuD,MACZ5B,GAAO4B,EAAKyB,SAASxE,qBACR,UAATmB,GAA6B,WAATA,IAAsB4B,EAAKvD,OAASA,GAQlE,QAAS0H,GAAsBC,SAGvB,UAAUpE,SAKX,QAAUA,GASTA,EAAKmC,YAAcnC,EAAKoE,YAAa,EAGpC,SAAWpE,GACV,SAAWA,GAAKmC,WACbnC,EAAKmC,WAAWiC,WAAaA,EAE7BpE,EAAKoE,WAAaA,EAMpBpE,EAAKqE,aAAeD,KAIrBC,cAAgBD,GACpBE,GAAoBtE,KAAWoE,EAG3BpE,EAAKoE,WAAaA,EAKd,SAAWpE,IACfA,EAAKoE,WAAaA,GAY5B,QAASG,GAAwBjF,SACzB0D,GAAa,SAAUwB,aACjBA,EACLxB,EAAa,SAAUlD,EAAM2E,UAC/BzG,GACH0G,EAAepF,KAAQQ,EAAK/B,OAAQyG,GACpCvG,EAAIyG,EAAa3G,OAGVE,KACF6B,EAAO9B,EAAI0G,EAAazG,QACvBD,KAAOyG,EAAQzG,GAAK8B,EAAK9B,SAYnC,QAASkE,GAAa7C,SACdA,IAAmD,mBAAjCA,GAAQ6B,sBAAwC7B,EAyjC1E,QAASsF,MAuET,QAAS5C,GAAY6C,UAChB3G,GAAI,EACP4G,EAAMD,EAAO7G,OACbqB,EAAW,GACJnB,EAAI4G,EAAK5G,OACJ2G,EAAO3G,GAAG0E,YAEhBvD,GAGR,QAAS0F,GAAeC,EAASC,EAAYC,MACxCC,GAAMF,EAAWE,IACpBC,EAAOH,EAAWI,KAClB1C,EAAMyC,GAAQD,EACdG,EAAmBJ,GAAgB,eAARvC,EAC3B4C,EAAWC,WAELP,GAAWnH,eAEPmC,EAAMX,EAASmG,QACfxF,EAAOA,EAAMkF,OACE,IAAlBlF,EAAKO,UAAkB8E,QACpBN,GAAS/E,EAAMX,EAASmG,UAG1B,YAIExF,EAAMX,EAASmG,MACpBC,GAAUC,EAAaC,EAC1BC,GAAaC,GAASP,MAGlBE,QACKxF,EAAOA,EAAMkF,QACE,IAAlBlF,EAAKO,UAAkB8E,IACtBN,EAAS/E,EAAMX,EAASmG,UACrB,YAKDxF,EAAOA,EAAMkF,OACE,IAAlBlF,EAAKO,UAAkB8E,OACdrF,EAAM6B,KAAc7B,EAAM6B,SAIzB8D,EAAY3F,EAAK8F,YAAeH,EAAY3F,EAAK8F,cAE1DX,GAAQA,IAASnF,EAAKyB,SAASxE,gBAC5B+C,EAAMkF,IAASlF,MAChB,CAAA,IAAMyF,EAAWC,EAAahD,KACpC+C,EAAU,KAAQI,IAAWJ,EAAU,KAAQH,QAGvCM,GAAU,GAAMH,EAAU,QAGrB/C,GAAQkD,EAGfA,EAAU,GAAMb,EAAS/E,EAAMX,EAASmG,UACtC,SAML,GAIV,QAASO,GAAgBC,SACjBA,GAASjI,OAAS,EACxB,SAAUiC,EAAMX,EAASmG,UACpBvH,GAAI+H,EAASjI,OACTE,SACD+H,EAAS/H,GAAI+B,EAAMX,EAASmG,UAC1B,SAGF,GAERQ,EAAS,GAGX,QAASC,GAAkB7G,EAAU8G,EAAUrG,UAC1C5B,GAAI,EACP4G,EAAMqB,EAASnI,OACRE,EAAI4G,EAAK5G,MACRmB,EAAU8G,EAASjI,GAAI4B,SAEzBA,GAGR,QAASsG,GAAUC,EAAWC,EAAKC,EAAQjH,EAASmG,UAC/CxF,GACHuG,KACAtI,EAAI,EACJ4G,EAAMuB,EAAUrI,OAChByI,EAAgB,MAAPH,EAEFpI,EAAI4G,EAAK5G,KACV+B,EAAOoG,EAAUnI,MAChBqI,IAAUA,EAAQtG,EAAMX,EAASmG,OACzBzE,KAAMf,GACdwG,KACAzF,KAAM9C,WAMPsI,GAGR,QAASE,GAAYC,EAAWtH,EAAU2F,EAAS4B,EAAYC,EAAYC,SACrEF,KAAeA,EAAY9E,OAClB4E,EAAYE,IAErBC,IAAeA,EAAY/E,OAClB4E,EAAYG,EAAYC,IAE/B7D,EAAa,SAAUlD,EAAMD,EAASR,EAASmG,MACjDsB,GAAM7I,EAAG+B,EACZ+G,KACAC,KACAC,EAAcpH,EAAQ9B,SAGd+B,GAAQmG,EAAkB7G,GAAY,IAAKC,EAAQkB,UAAalB,GAAYA,SAGxEqH,IAAe5G,GAASV,EAEnC8H,EADAf,EAAUe,EAAOH,EAAQL,EAAWrH,EAASmG,GAG9C2B,EAAapC,MAEIjF,EAAO4G,EAAYO,GAAeN,QAOlDS,KAGGrC,KACKqC,EAAWD,EAAY9H,EAASmG,GAIrCmB,QACGR,EAAUgB,EAAYH,KACjBF,KAAUzH,EAASmG,KAG3BsB,EAAK/I,OACDE,MACD+B,EAAO8G,EAAK7I,QACL+I,EAAQ/I,MAASmJ,EAAWJ,EAAQ/I,IAAO+B,OAKrDF,MACC8G,GAAcF,EAAY,IACzBE,EAAa,YAGbO,EAAWpJ,OACPE,MACD+B,EAAOmH,EAAWlJ,OAElB8C,KAAOqG,EAAUnJ,GAAK+B,KAGjB,KAAOmH,KAAkBL,EAAMtB,SAIxC2B,EAAWpJ,OACPE,MACD+B,EAAOmH,EAAWlJ,MACtB6I,EAAOF,EAAaS,GAASvH,EAAME,GAAS+G,EAAO9I,KAAM,MAErD6I,KAAUjH,EAAQiH,GAAQ9G,YAOrBmG,EACZgB,IAAetH,EACdsH,EAAWG,OAAQL,EAAaE,EAAWpJ,QAC3CoJ,GAEGP,IACQ,KAAM/G,EAASsH,EAAY3B,MAElCvE,MAAOpB,EAASsH,KAMzB,QAASI,GAAmB3C,UACvB4C,GAAczC,EAAS/G,EAC1B6G,EAAMD,EAAO7G,OACb0J,EAAkB5E,EAAK6E,SAAU9C,EAAO,GAAGnI,MAC3CkL,EAAmBF,GAAmB5E,EAAK6E,SAAS,KACpDzJ,EAAIwJ,EAAkB,EAAI,IAGX3C,EAAe,SAAU9E,SAChCA,KAASwH,GACdG,GAAkB,GACrBC,EAAkB9C,EAAe,SAAU9E,SACnCqH,IAASG,EAAcxH,IAAS,GACrC2H,GAAkB,GACrB3B,GAAa,SAAUhG,EAAMX,EAASmG,MACjCqC,IAASJ,IAAqBjC,GAAOnG,IAAYyI,MACnDN,EAAenI,GAASkB,SACxBwH,EAAc/H,EAAMX,EAASmG,GAC7BoC,EAAiB5H,EAAMX,EAASmG,aAEnB,KACRqC,IAGD5J,EAAI4G,EAAK5G,OACV8G,EAAUlC,EAAK6E,SAAU9C,EAAO3G,GAAGxB,SAC3BqI,EAAciB,EAAgBC,GAAYjB,QACjD,MACIlC,EAAKyD,OAAQ1B,EAAO3G,GAAGxB,MAAOwE,MAAO,KAAM2D,EAAO3G,GAAGwG,SAG1DM,EAASlD,GAAY,SAEnB5D,EACED,EAAI6G,IACNhC,EAAK6E,SAAU9C,EAAO5G,GAAGvB,MADduB,WAKVyI,GACNxI,EAAI,GAAK8H,EAAgBC,GACzB/H,EAAI,GAAK8D,IAEDiG,MAAO,EAAG/J,EAAI,GAAIgK,QAAStF,MAAgC,MAAzBiC,EAAQ3G,EAAI,GAAIxB,KAAe,IAAM,MAC7ED,QAASD,GAAO,MAClBwI,EACA9G,EAAID,GAAKuJ,EAAmB3C,EAAOoD,MAAO/J,EAAGD,IAC7CA,EAAI6G,GAAO0C,EAAoB3C,EAASA,EAAOoD,MAAOhK,IACtDA,EAAI6G,GAAO9C,EAAY6C,MAGhB7D,KAAMgE,SAIVgB,GAAgBC,GAGxB,QAASkC,GAA0BC,EAAiBC,MAC/CC,GAAQD,EAAYrK,OAAS,EAChCuK,EAAYH,EAAgBpK,OAAS,EACrCwK,EAAe,SAAUzI,EAAMT,EAASmG,EAAK3F,EAAS2I,MACjDxI,GAAMhC,EAAG+G,EACZ0D,EAAe,EACfxK,EAAI,IACJmI,EAAYtG,MACZ4I,KACAC,EAAgBb,IAERhI,GAAQwI,GAAazF,EAAKnD,KAAL,IAAkB,IAAK8I,KAEnC3C,IAA4B,MAAjB8C,EAAwB,EAAIC,KAAKC,UAAY,GACzEhE,EAAMqC,EAAMnJ,WAERyK,MACenJ,IAAYoB,GAAYpB,GAAWmJ,GAM/CvK,IAAM4G,GAA4B,OAApB7E,EAAOkH,EAAMjJ,IAAaA,IAAM,IAChDqK,GAAatI,EAAO,OACpB,EACEX,GAAWW,EAAKM,gBAAkBG,MAC1BT,MACNU,GAECqE,EAAUoD,EAAgBnK,SAC7B+G,EAAS/E,EAAMX,GAAWoB,EAAU+E,GAAO,GACvCzE,KAAMf,SAIXwI,OACMM,GAKPT,KAEErI,GAAQ+E,GAAW/E,QAKpBF,KACMiB,KAAMf,UAOH/B,EASXoK,GAASpK,IAAMwK,EAAe,OAC9B,EACK1D,EAAUqD,EAAYpK,QACrBoI,EAAWsC,EAAYrJ,EAASmG,MAGrC1F,EAAO,IAEN2I,EAAe,OACXxK,KACAmI,EAAUnI,IAAMyK,EAAWzK,OACtBA,GAAK8K,GAAIlM,KAAMgD,MAMhBsG,EAAUuC,MAInBzH,MAAOpB,EAAS6I,GAGhBF,IAAc1I,GAAQ4I,EAAW3K,OAAS,GAC5C0K,EAAeL,EAAYrK,OAAW,KAEjCiL,WAAYnJ,SAKhB2I,QACMM,IACSH,GAGbvC,SAGFiC,GACNrF,EAAcuF,GACdA,ECphEa,QAASU,GAAW9J,KAC1BO,KAAOE,4LJHVsJ,EAAY,OACZC,EAAS,0BAOD,SAAkBC,MACpBC,UAASC,SAAOrK,SAAI4E,SAAK0F,SAAUC,SAAYxL,SAAGC,EAAI,KAEvC,gBAARmL,IAAoBA,QACjBA,EAAIlJ,MAAMgJ,OAEbjK,EAAKL,KAAKX,WACFe,EAASC,KACG,IAAhBA,EAAGsB,eAAuBgJ,OAAY/M,QAAQ2M,EAAQ,WAGrD,EAEGG,EAAQD,EAAQrL,MAEf6F,EAAIwD,YAAYiC,SAAa,OACtBA,EAAQ,OAENnK,KAAK9C,KAAKwH,GAClB0F,IAAaC,KACX5H,aAAa,QAAS4H,SAOtC5K,mBAEE,SAAqBwK,MAC1BC,UAASC,SAAOrK,SAAI4E,SAAK0F,SAAUC,SAAYxL,SAAGC,EAAI,KAErDS,UAAUX,WAII,gBAARqL,IAAoBA,QACjBA,EAAIlJ,MAAMgJ,OAEbjK,EAAKL,KAAKX,WACFe,EAASC,KACG,IAAhBA,EAAGsB,eAAuBgJ,OAAY/M,QAAQ2M,EAAQ,WAGrD,EAEGG,EAAQD,EAAQrL,MAEf6F,EAAIwD,YAAYiC,UAAc,MACxBzF,EAAIrH,YAAY8M,MAAU,QAEvBnK,KAAK9C,KAAKwH,GAClB0F,IAAaC,KACX5H,aAAa,QAAS4H,SAOtC5K,iBAED,SAAkBwK,UACpBnK,UAAIhB,EAAI,EAAGwL,MAAgBL,MAExBnK,EAAKL,KAAKX,SAEO,IAAhBgB,EAAGsB,eAECvB,EAASC,QAAOzC,QAAQ2M,EAAQ,KAAK9B,QAAQoC,MAAe,SAEzD,SAIR,eAEE,SAAqBL,UAC1BnK,UAAIhB,EAAI,EAELgB,EAAKL,KAAKX,YACTW,MAAK8K,SAASN,SACTO,YAAYP,GACVxK,YAEFgL,SAASR,GACPxK,UCtFlBU,GAAKH,EAAKQ,sBACCR,SACJ,KAGPjB,OAASiB,EAAKG,GAAGpB,OAASA,IAE1BA,2BASAoB,GAAGpB,kBACO,SAAUuB,MACboI,GAAMjK,EAAMgB,KAAKiL,aAAcpK,YAC/BqK,WAAalL,KACViJ,QAEL,SAAUzI,UACRnB,GAAI,EACJ4G,EAAMjG,KAAKb,OACXgM,EAAOnL,KACPiJ,EAAMjJ,KAAKoL,cAER/L,EAAI4G,EAAK5G,MACPyB,KAAKN,EAAU2K,EAAM9L,GAAK4J,SAG5BA,QAEN,iBACMjJ,MAAKkL,YAAclL,KAAKlB,kBAE/B,SAAYO,MACR4G,GAAMjG,KAAKb,OACXC,GAAKC,GAAMA,EAAI,EAAI4G,EAAM,SACtBjG,MAAKoL,UAAUhM,GAAK,GAAKA,EAAI6G,GAAOjG,KAAKZ,eAE7C,iBACIY,MAAKqL,GAAG,SAEb,iBACKrL,MAAKqL,IAAG,QAOlB3K,GAAGpB,OAAOgM,GAEfC,OAAOhL,KAAOgL,OAAOC,EAAID,OAAOE,GAAKlL,KExDjClB,GACHkD,EACA0B,EACAyH,EACAC,EACAzI,EACA0I,EACAjI,EACAuF,EACA2C,EACAC,EAGAC,EACAlK,EACAmK,EACAlK,EACAa,EACAsJ,EACApG,EACAzD,EAGAa,EAAU,SAAW,EAAI,GAAIiJ,MAC7BtK,EAAe2J,OAAO1J,SACtBoF,GAAU,EACVN,GAAO,EACPwF,GAAavI,IACbwI,GAAaxI,IACblB,GAAgBkB,IAChByI,GAAY,SAAUtH,EAAGC,SACnBD,KAAMC,OACK,GAET,GAIRrG,MAAcF,eACdmG,MACAuF,GAAMvF,GAAIuF,IACVmC,GAAc1H,GAAIzC,KAClBA,GAAOyC,GAAIzC,KACXiH,GAAQxE,GAAIwE,MAGZX,GAAU,SAAU8D,EAAMnL,UACrB/B,GAAI,EACP4G,EAAMsG,EAAKpN,OACJE,EAAI4G,EAAK5G,OACXkN,EAAKlN,KAAO+B,QACT/B,UAGF,GAGRmN,GAAW,6HAKXC,GAAa,sBAGbC,GAAa,gCAGbC,GAAa,MAAQF,GAAa,KAAOC,GAAa,OAASD,GAE9D,gBAAkBA,GAElB,2DAA6DC,GAAa,OAASD,GACnF,OAEDG,GAAU,KAAOF,GAAa,wFAKAC,GAAa,eAM3CE,GAAc,GAAIC,QAAQL,GAAa,IAAK,KAC5C9O,GAAQ,GAAImP,QAAQ,IAAML,GAAa,8BAAgCA,GAAa,KAAM,KAE1FM,GAAS,GAAID,QAAQ,IAAML,GAAa,KAAOA,GAAa,KAC5DO,GAAe,GAAIF,QAAQ,IAAML,GAAa,WAAaA,GAAa,IAAMA,GAAa,KAE3FQ,GAAmB,GAAIH,QAAQ,IAAML,GAAa,iBAAmBA,GAAa,OAAQ,KAE1FS,GAAU,GAAIJ,QAAQF,IACtBO,GAAc,GAAIL,QAAQ,IAAMJ,GAAa,KAE7CU,OACO,GAAIN,QAAQ,MAAQJ,GAAa,WAC9B,GAAII,QAAQ,QAAUJ,GAAa,SACrC,GAAII,QAAQ,KAAOJ,GAAa,cAC/B,GAAII,QAAQ,IAAMH,WAChB,GAAIG,QAAQ,IAAMF,UACnB,GAAIE,QAAQ,yDAA2DL,GAC/E,+BAAiCA,GAAa,cAAgBA,GAC9D,aAAeA,GAAa,SAAU,UAC/B,GAAIK,QAAQ,OAASN,GAAW,KAAM,kBAG9B,GAAIM,QAAQ,IAAML,GAAa,mDAC9CA,GAAa,mBAAqBA,GAAa,mBAAoB,MAGrEY,GAAU,sCACVC,GAAU,SAEVC,GAAU,yBAGVxL,GAAa,mCAEbsB,GAAW,OAIXmK,GAAY,GAAIV,QAAQ,qBAAuBL,GAAa,MAAQA,GAAa,OAAQ,MACzFgB,GAAY,SAAUC,EAAGC,EAASC,MAC7BC,GAAO,KAAOF,EAAU,YAIrBE,KAASA,GAAQD,EACvBD,EACAE,EAAO,SAECC,aAAcD,EAAO,cAErBC,aAAcD,GAAQ,GAAK,MAAe,KAAPA,EAAe,QAK5D/K,GAAa,sDACbC,GAAa,SAAUgL,EAAIC,SACrBA,GAGQ,OAAPD,EACG,IAIDA,EAAG3E,MAAO,GAAG,GAAO,KAAO2E,EAAGE,WAAYF,EAAG5O,OAAS,GAAInB,SAAU,IAAO,IAI5E,KAAO+P,GAOfG,GAAgB,gBAIhBxI,GAAqBQ,EACpB,SAAU9E,SACFA,GAAKoE,YAAa,GAAwC,aAAhCpE,EAAKyB,SAASxE,gBAE9CiI,IAAK,aAAcE,KAAM,UAI7B,QACMnE,MACHuC,GAAMwE,GAAMnL,KAAM2D,EAAauM,YAChCvM,EAAauM,eAITvM,EAAauM,WAAWhP,QAASwC,SACrC,MAAQ4C,OACAlC,MAAOuC,GAAIzF,gBAGTU,EAAQgB,MACLwB,MAAOxC,EAAQuJ,GAAMnL,KAAK4C,cAK7BhB,EAAQgB,UACbzB,GAAIS,EAAOV,OACdE,EAAI,EAEIQ,EAAOT,KAAOyB,EAAIxB,SACpBF,OAASC,EAAI,IAoVvBmD,EAAUvB,EAAOuB,WAOjBoJ,EAAQ3K,EAAO2K,MAAQ,SAAUvK,MAG5BgN,GAAkBhN,IAASA,EAAKM,eAAiBN,GAAMgN,wBACpDA,GAA+C,SAA7BA,EAAgBvL,UAQ1CkJ,EAAc/K,EAAO+K,YAAc,SAAUsC,MACxCC,GAAYC,EACfC,EAAMH,EAAOA,EAAK3M,eAAiB2M,EAAOzM,QAGtC4M,KAAQ3M,GAA6B,IAAjB2M,EAAI7M,UAAmB6M,EAAIJ,mBAKzCI,IACD3M,EAASuM,mBACDzC,EAAO9J,GAIpBD,IAAiBC,IACpB0M,EAAY1M,EAAS4M,cAAgBF,EAAUG,MAAQH,IAGnDA,EAAUI,mBACJA,iBAAkB,SAAUT,IAAe,GAG1CK,EAAUK,eACXA,YAAa,WAAYV,OAU7BvB,WAAatI,EAAO,SAAUhE,YAClCwK,UAAY,KACPxK,EAAGC,aAAa,iBAOjBgC,qBAAuB+B,EAAO,SAAUhE,YAC5CwO,YAAahN,EAASiN,cAAc,MAC/BzO,EAAGiC,qBAAqB,KAAKnD,WAI9BqD,uBAAyB+K,GAAQ3K,KAAMf,EAASW,0BAMhDuM,QAAU1K,EAAO,SAAUhE,YAC1BwO,YAAaxO,GAAK6B,GAAKe,GACvBpB,EAASmN,oBAAsBnN,EAASmN,kBAAmB/L,GAAU9D,SAIzEoD,EAAQwM,WACPrH,OAAL,GAAoB,SAAUxF,MACzB+M,GAAS/M,EAAGtE,QAAS4P,GAAWC,UAC7B,UAAUrM,SACTA,GAAKd,aAAa,QAAU2O,MAGhCnO,KAAL,GAAkB,SAAUoB,EAAIzB,MACQ,mBAA3BA,GAAQwB,gBAAkCH,EAAiB,IAClEV,GAAOX,EAAQwB,eAAgBC,SAC5Bd,IAASA,YAIbsG,OAAL,GAAqB,SAAUxF,MAC1B+M,GAAS/M,EAAGtE,QAAS4P,GAAWC,UAC7B,UAAUrM,MACZiN,GAAwC,mBAA1BjN,GAAK8N,kBACtB9N,EAAK8N,iBAAiB,YAChBb,IAAQA,EAAKtK,QAAUkL,MAM3BnO,KAAL,GAAkB,SAAUoB,EAAIzB,MACQ,mBAA3BA,GAAQwB,gBAAkCH,EAAiB,IAClEuM,GAAMhP,EAAGiJ,EACZlH,EAAOX,EAAQwB,eAAgBC,MAE3Bd,EAAO,MAGJA,EAAK8N,iBAAiB,MACxBb,GAAQA,EAAKtK,QAAU7B,SAClBd,SAIFX,EAAQuO,kBAAmB9M,KAC/B,EACKd,EAAOkH,EAAMjJ,WACd+B,EAAK8N,iBAAiB,MACxBb,GAAQA,EAAKtK,QAAU7B,SAClBd,iBAWVN,KAAL,IAAmByB,EAAQD,qBAC1B,SAAU6M,EAAK1O,SAC+B,mBAAjCA,GAAQ6B,qBACZ7B,EAAQ6B,qBAAsB6M,GAG1B5M,EAAQE,IACZhC,EAAQ+C,iBAAkB2L,GAD3B,QAKR,SAAUA,EAAK1O,MACVW,GACHgO,KACA/P,EAAI,IAEMoB,EAAQ6B,qBAAsB6M,MAG5B,MAARA,EAAc,MACT/N,EAAOH,EAAQ5B,MACA,IAAlB+B,EAAKO,YACLQ,KAAMf,SAILgO,SAEDnO,MAIJH,KAAL,MAAqByB,EAAQC,wBAA0B,SAAUqI,EAAWpK,MAC5B,mBAAnCA,GAAQ+B,wBAA0CV,QACtDrB,GAAQ+B,uBAAwBqI,eAmBnCtI,EAAQE,IAAM8K,GAAQ3K,KAAMf,EAAS2B,uBAGnC,SAAUnD,KAMRwO,YAAaxO,GAAKgP,UAAY,UAAYpM,EAAU,qBAC1CA,EAAU,kEAOvB5C,EAAGmD,iBAAiB,wBAAwBrE,UACtCgD,KAAM,SAAWsK,GAAa,gBAKnCpM,EAAGmD,iBAAiB,cAAcrE,UAC7BgD,KAAM,MAAQsK,GAAa,aAAeD,GAAW,KAI1DnM,EAAGmD,iBAAkB,QAAUP,EAAU,MAAO9D,UAC3CgD,KAAK,MAMV9B,EAAGmD,iBAAiB,YAAYrE,UAC3BgD,KAAK,YAMV9B,EAAGmD,iBAAkB,KAAOP,EAAU,MAAO9D,UACxCgD,KAAK,gBAIV,SAAU9B,KACbgP,UAAY,uFAKXC,GAAQzN,EAASyC,cAAc,WAC7BtB,aAAc,OAAQ,YACzB6L,YAAaS,GAAQtM,aAAc,OAAQ,KAIzC3C,EAAGmD,iBAAiB,YAAYrE,UAC1BgD,KAAM,OAASsK,GAAa,eAKS,IAA3CpM,EAAGmD,iBAAiB,YAAYrE,UAC1BgD,KAAM,WAAY,eAKrB0M,YAAaxO,GAAKmF,UAAW,EACY,IAA5CnF,EAAGmD,iBAAiB,aAAarE,UAC3BgD,KAAM,WAAY,eAI1BqB,iBAAiB,UACVrB,KAAK,YAIXI,EAAQgN,gBAAkBhC,GAAQ3K,KAAOiD,EAAUmG,EAAQnG,SAChEmG,EAAQwD,uBACRxD,EAAQyD,oBACRzD,EAAQ0D,kBACR1D,EAAQ2D,uBAED,SAAUtP,KAGRuP,kBAAoB/J,EAAQ5H,KAAMoC,EAAI,OAItCpC,KAAMoC,EAAI,eACJ8B,KAAM,KAAMyK,QAIhBjK,EAAUxD,QAAU,GAAI2N,QAAQnK,EAAUS,KAAK,QAC3C6I,EAAc9M,QAAU,GAAI2N,QAAQb,EAAc7I,KAAK,QAI1DmK,GAAQ3K,KAAMoJ,EAAQ6D,2BAKxBvB,GAAcf,GAAQ3K,KAAMoJ,EAAQ5J,UAC9C,SAAU2C,EAAGC,MACR8K,GAAuB,IAAf/K,EAAEpD,SAAiBoD,EAAEqJ,gBAAkBrJ,EAClDgL,EAAM/K,GAAKA,EAAEzB,iBACPwB,KAAMgL,MAAWA,GAAwB,IAAjBA,EAAIpO,YAClCmO,EAAM1N,SACL0N,EAAM1N,SAAU2N,GAChBhL,EAAE8K,yBAA8D,GAAnC9K,EAAE8K,wBAAyBE,MAG3D,SAAUhL,EAAGC,MACPA,OACKA,EAAIA,EAAEzB,eACTyB,IAAMD,SACH,SAIH,MAOGuJ,EACZ,SAAUvJ,EAAGC,MAGPD,IAAMC,YACK,EACR,KAIJgL,IAAWjL,EAAE8K,yBAA2B7K,EAAE6K,8BACzCG,GACGA,MAIIjL,EAAErD,eAAiBqD,MAAUC,EAAEtD,eAAiBsD,GAC3DD,EAAE8K,wBAAyB7K,KAMb,EAAVgL,IACFzN,EAAQ0N,cAAgBjL,EAAE6K,wBAAyB9K,KAAQiL,EAGxDjL,IAAMlD,GAAYkD,EAAErD,gBAAkBE,GAAgBQ,EAASR,EAAcmD,IAC1E,EAEHC,IAAMnD,GAAYmD,EAAEtD,gBAAkBE,GAAgBQ,EAASR,EAAcoD,GAC1E,EAID6G,EACJpD,GAASoD,EAAW9G,GAAM0D,GAASoD,EAAW7G,GAChD,EAGe,EAAVgL,GAAc,EAAK,IAE3B,SAAUjL,EAAGC,MAEPD,IAAMC,YACK,EACR,KAGJC,GACH5F,EAAI,EACJ6Q,EAAMnL,EAAExB,WACRwM,EAAM/K,EAAEzB,WACR4M,GAAOpL,GACPqL,GAAOpL,OAGFkL,IAAQH,QACNhL,KAAMlD,GAAW,EACvBmD,IAAMnD,EAAW,EACjBqO,GAAM,EACNH,EAAM,EACNlE,EACEpD,GAASoD,EAAW9G,GAAM0D,GAASoD,EAAW7G,GAChD,CAGK,IAAKkL,IAAQH,QACZjL,GAAcC,EAAGC,SAInBD,EACGE,EAAMA,EAAI1B,cACf8M,QAASpL,SAEPD,EACGC,EAAMA,EAAI1B,cACf8M,QAASpL,QAILkL,EAAG9Q,KAAO+Q,EAAG/Q,cAIdA,KAEQ8Q,EAAG9Q,GAAI+Q,EAAG/Q,MAGrBA,KAAOuC,GAAe,EACzBwO,EAAG/Q,KAAOuC,EAAe,EACzB,GAGKC,GA3YCA,GA8YTb,EAAO6E,QAAU,SAAUyK,EAAMC,SACzBvP,GAAQsP,EAAM,KAAM,KAAMC,IAGlCvP,EAAOuO,gBAAkB,SAAUnO,EAAMkP,OAEjClP,EAAKM,eAAiBN,KAAWS,KAC1BT,KAIPkP,EAAK1S,QAASqP,GAAkB,UAElC1K,EAAQgN,iBAAmBzN,IAC9BY,GAAe4N,EAAO,QACpBrE,IAAkBA,EAAcrJ,KAAM0N,OACtC3N,IAAkBA,EAAUC,KAAM0N,WAGhCrH,GAAMpD,EAAQ5H,KAAMmD,EAAMkP,MAGzBrH,GAAO1G,EAAQqN,qBAGb/N,UAAuC,KAA3BT,EAAKS,SAASF,eACzBsH,GAEP,MAAO1E,UAGHvD,GAAQsP,EAAMzO,EAAU,MAAQT,IAASjC,OAAS,GAG1D6B,EAAOoB,SAAW,SAAU3B,EAASW,UAE7BX,EAAQiB,eAAiBjB,KAAcoB,KAChCpB,GAEP2B,EAAU3B,EAASW,IAG3BJ,EAAOwP,KAAO,SAAUpP,EAAM5B,IAEtB4B,EAAKM,eAAiBN,KAAWS,KAC1BT,MAGVV,GAAKuD,EAAKY,WAAYrF,EAAKnB,iBAExBqC,GAAM/B,GAAOV,KAAMgG,EAAKY,WAAYrF,EAAKnB,eAC9CqC,EAAIU,EAAM5B,GAAOsC,GACjB3B,aAEaA,UAARsQ,EACNA,EACAlO,EAAQoK,aAAe7K,EACtBV,EAAKd,aAAcd,IAClBiR,EAAMrP,EAAK8N,iBAAiB1P,KAAUiR,EAAIC,UAC1CD,EAAI1M,MACJ,MAGJ/C,EAAO2P,OAAS,SAAUC,UACjBA,EAAM,IAAIhT,QAASkF,GAAYC,KAGxC/B,EAAO6P,MAAQ,SAAUC,QAClB,IAAIC,OAAO,0CAA4CD,IAO9D9P,EAAOoJ,WAAa,SAAUnJ,MACzBG,GACH4P,KACA5R,EAAI,EACJC,EAAI,QAGWkD,EAAQ0O,oBACX1O,EAAQ2O,YAAcjQ,EAAQmI,MAAO,KAC1C+H,KAAM9E,IAETP,EAAe,MACV1K,EAAOH,EAAQ5B,MAClB+B,IAASH,EAAS5B,OAClB2R,EAAW7O,KAAM9C,SAGfD,OACCsJ,OAAQsI,EAAY5R,GAAK,YAMvB,KAEL6B,GAORyK,EAAU1K,EAAO0K,QAAU,SAAUtK,MAChCiN,GACHpF,EAAM,GACN5J,EAAI,EACJsC,EAAWP,EAAKO,YAEXA,GAMC,GAAkB,IAAbA,GAA+B,IAAbA,GAA+B,KAAbA,EAAkB,IAGhC,gBAArBP,GAAKgQ,kBACThQ,GAAKgQ,gBAGNhQ,EAAOA,EAAKiQ,WAAYjQ,EAAMA,EAAOA,EAAKgE,eACxCsG,EAAStK,OAGZ,IAAkB,IAAbO,GAA+B,IAAbA,QACtBP,GAAKkQ,oBAhBHjD,EAAOjN,EAAK/B,SAEbqM,EAAS2C,SAkBXpF,IAGRhF,EAAOjD,EAAOuQ,uBAGA,gBAECnN,QAEPgJ,wCAOC9G,IAAK,aAAcrH,OAAO,QAC1BqH,IAAK,mBACLA,IAAK,kBAAmBrH,OAAO,QAC/BqH,IAAK,oCAIJ,SAAUhF,YACX,GAAKA,EAAM,GAAG1D,QAAS4P,GAAWC,MAGlC,IAAOnM,EAAM,IAAMA,EAAM,IAAMA,EAAM,IAAM,IAAK1D,QAAS4P,GAAWC,IAExD,OAAbnM,EAAM,OACJ,GAAK,IAAMA,EAAM,GAAK,KAGtBA,EAAM8H,MAAO,EAAG,UAGf,SAAU9H,YAWZ,GAAKA,EAAM,GAAGjD,cAEY,QAA3BiD,EAAM,GAAG8H,MAAO,EAAG,IAEjB9H,EAAM,MACJuP,MAAOvP,EAAM,MAKf,KAAQA,EAAM,GAAKA,EAAM,IAAMA,EAAM,IAAM,GAAK,GAAmB,SAAbA,EAAM,IAA8B,QAAbA,EAAM,OACnF,KAAUA,EAAM,GAAKA,EAAM,IAAqB,QAAbA,EAAM,KAGpCA,EAAM,MACVuP,MAAOvP,EAAM,IAGdA,UAGE,SAAUA,MACfkQ,GACHC,GAAYnQ,EAAM,IAAMA,EAAM,SAE1B8L,IAAA,MAAmBxK,KAAMtB,EAAM,IAC5B,MAIHA,EAAM,KACJ,GAAKA,EAAM,IAAMA,EAAM,IAAM,GAGxBmQ,GAAYvE,GAAQtK,KAAM6O,OAE3BvO,EAAUuO,GAAU,QAEpBA,EAAShJ,QAAS,IAAKgJ,EAAStS,OAASqS,GAAWC,EAAStS,YAGjE,GAAKmC,EAAM,GAAG8H,MAAO,EAAGoI,KACxB,GAAKC,EAASrI,MAAO,EAAGoI,IAIxBlQ,EAAM8H,MAAO,EAAG,kBAMjB,SAAUsI,MACZ7O,GAAW6O,EAAiB9T,QAAS4P,GAAWC,IAAYpP,oBACpC,MAArBqT,EACN,kBAAoB,GACpB,SAAUtQ,SACFA,GAAKyB,UAAYzB,EAAKyB,SAASxE,gBAAkBwE,UAIlD,SAAUgI,MACd8G,GAAUxF,GAAYtB,EAAY,WAE/B8G,KACLA,EAAU,GAAI7E,QAAQ,MAAQL,GAAa,IAAM5B,EAAY,IAAM4B,GAAa,SACjFN,GAAYtB,EAAW,SAAUzJ,SACzBuQ,GAAQ/O,KAAgC,gBAAnBxB,GAAKyJ,WAA0BzJ,EAAKyJ,WAA0C,mBAAtBzJ,GAAKd,cAAgCc,EAAKd,aAAa,UAAY,YAIlJ,SAAUd,EAAMoS,EAAUC,SAC1B,UAAUzQ,MACZ0Q,GAAS9Q,EAAOwP,KAAMpP,EAAM5B,SAEjB,OAAVsS,EACgB,OAAbF,GAEFA,OAII,GAEU,MAAbA,EAAmBE,IAAWD,EACvB,OAAbD,EAAoBE,IAAWD,EAClB,OAAbD,EAAoBC,GAAqC,IAA5BC,EAAOrJ,QAASoJ,GAChC,OAAbD,EAAoBC,GAASC,EAAOrJ,QAASoJ,IAAU,EAC1C,OAAbD,EAAoBC,GAASC,EAAO1I,OAAQyI,EAAM1S,UAAa0S,EAClD,OAAbD,GAAsB,IAAME,EAAOlU,QAASiP,GAAa,KAAQ,KAAMpE,QAASoJ,IAAU,EAC7E,OAAbD,IAAoBE,IAAWD,GAASC,EAAO1I,MAAO,EAAGyI,EAAM1S,OAAS,KAAQ0S,EAAQ,cAKlF,SAAUhU,EAAMkU,EAAMnM,EAAU3G,EAAO+S,MAC3CC,GAAgC,QAAvBpU,EAAKuL,MAAO,EAAG,GAC3B8I,EAA+B,SAArBrU,EAAKuL,OAAO,GACtB+I,EAAkB,YAATJ,QAEO,KAAV9S,GAAwB,IAAT+S,WAGX5Q,WACAA,EAAKmC,YAGf,SAAUnC,EAAMX,EAASmG,MACpB/C,GAAOiD,EAAaC,EAAYsH,EAAM+D,EAAWC,EACpD/L,EAAM2L,IAAWC,EAAU,cAAgB,kBAC3CI,EAASlR,EAAKmC,WACd/D,EAAO2S,GAAU/Q,EAAKyB,SAASxE,cAC/BkU,GAAY3L,IAAQuL,EACpBjN,GAAO,KAEHoN,EAAS,IAGRL,EAAS,MACL3L,GAAM,OACNlF,EACEiN,EAAOA,EAAM/H,OAChB6L,EACJ9D,EAAKxL,SAASxE,gBAAkBmB,EACd,IAAlB6O,EAAK1M,gBAEE,IAID2E,EAAe,SAATzI,IAAoBwU,GAAS,qBAErC,QAGEH,EAAUI,EAAOjB,WAAaiB,EAAOE,WAG1CN,GAAWK,SAKRD,IACMjE,EAAMpL,KAAcoL,EAAMpL,SAIzB8D,EAAYsH,EAAKnH,YAC7BH,EAAYsH,EAAKnH,gBAEXJ,EAAajJ,SACTgG,EAAO,KAAQoD,IAAWpD,EAAO,KACtCuO,GAAavO,EAAO,KACpBuO,GAAaE,EAAOnE,WAAYiE,GAE9B/D,IAAS+D,GAAa/D,GAAQA,EAAM/H,OAGpC8L,EAAY,IAAMC,EAAMlI,UAGT,IAAlBkE,EAAK1M,YAAoBuD,GAAQmJ,IAASjN,EAAO,GACxCvD,IAAWoJ,GAASmL,EAAWlN,kBAOzCqN,MAEGnR,IACMiN,EAAMpL,KAAcoL,EAAMpL,SAIzB8D,EAAYsH,EAAKnH,YAC7BH,EAAYsH,EAAKnH,gBAEXJ,EAAajJ,SACTgG,EAAO,KAAQoD,IAAWpD,EAAO,KACtCuO,GAKHlN,KAAS,QAEJmJ,IAAS+D,GAAa/D,GAAQA,EAAM/H,KAC3CpB,EAAOkN,EAAY,IAAMC,EAAMlI,UAEzBgI,EACN9D,EAAKxL,SAASxE,gBAAkBmB,EACd,IAAlB6O,EAAK1M,cACHuD,IAGGqN,MACSlE,EAAMpL,KAAcoL,EAAMpL,SAIzB8D,EAAYsH,EAAKnH,YAC7BH,EAAYsH,EAAKnH,gBAENrJ,IAAWoJ,GAAS/B,IAG7BmJ,IAASjN,gBASV4Q,EACD9M,IAASjG,GAAWiG,EAAOjG,IAAU,GAAKiG,EAAOjG,GAAS,YAK3D,SAAUwT,EAAQ7M,MAKvB8M,GACHhS,EAAKuD,EAAK2I,QAAS6F,IAAYxO,EAAK8B,WAAY0M,EAAOpU,gBACtD2C,EAAO6P,MAAO,uBAAyB4B,SAKpC/R,GAAIuC,GACDvC,EAAIkF,GAIPlF,EAAGvB,OAAS,MACPsT,EAAQA,EAAQ,GAAI7M,GACtB3B,EAAK8B,WAAWtH,eAAgBgU,EAAOpU,eAC7C+F,EAAa,SAAUlD,EAAM2E,UACxB8M,GACHC,EAAUlS,EAAIQ,EAAM0E,GACpBvG,EAAIuT,EAAQzT,OACLE,OACDoJ,GAASvH,EAAM0R,EAAQvT,MACvBsT,KAAW9M,EAAS8M,GAAQC,EAAQvT,MAG5C,SAAU+B,SACFV,GAAIU,EAAM,EAAGsR,KAIhBhS,iBAMD0D,EAAa,SAAU5D,MAIzB8O,MACHrO,KACAkF,EAAUyF,EAASpL,EAAS5C,QAASD,GAAO,aAEtCwI,GAASlD,GACfmB,EAAa,SAAUlD,EAAM2E,EAASpF,EAASmG,UAC1CxF,GACHoG,EAAYrB,EAASjF,EAAM,KAAM0F,MACjCvH,EAAI6B,EAAK/B,OAGFE,MACD+B,EAAOoG,EAAUnI,QACjBA,KAAOwG,EAAQxG,GAAK+B,MAI5B,SAAUA,EAAMX,EAASmG,YAClB,GAAKxF,IACFkO,EAAO,KAAM1I,EAAK3F,KAErB,GAAK,MACHA,EAAQkJ,aAIZ/F,EAAa,SAAU5D,SACtB,UAAUY,SACTJ,GAAQR,EAAUY,GAAOjC,OAAS,cAI/BiF,EAAa,SAAU1G,YAC3BA,EAAKE,QAAS4P,GAAWC,IACzB,SAAUrM,UACPA,EAAKgQ,aAAehQ,EAAKyR,WAAanH,EAAStK,IAASqH,QAAS/K,IAAS,UAW7E0G,EAAc,SAAU0O,SAEzB3F,IAAYvK,KAAKkQ,GAAQ,OACvBjC,MAAO,qBAAuBiC,KAE/BA,EAAKlV,QAAS4P,GAAWC,IAAYpP,cACrC,SAAU+C,MACZ2R,SAEGA,EAAWjR,EAChBV,EAAK0R,KACL1R,EAAKd,aAAa,aAAec,EAAKd,aAAa,iBAExCyS,EAAS1U,cACb0U,IAAaD,GAA2C,IAAnCC,EAAStK,QAASqK,EAAO,YAE5C1R,EAAOA,EAAKmC,aAAiC,IAAlBnC,EAAKO,iBACpC,YAKC,SAAUP,MACf4R,GAAOzH,OAAO0H,UAAY1H,OAAO0H,SAASD,WACvCA,IAAQA,EAAK5J,MAAO,KAAQhI,EAAKc,SAGjC,SAAUd,SACVA,KAAS4K,SAGR,SAAU5K,SACXA,KAASS,EAASqR,iBAAmBrR,EAASsR,UAAYtR,EAASsR,gBAAkB/R,EAAKvD,MAAQuD,EAAKgS,OAAShS,EAAKiS,mBAIlH9N,GAAsB,YACrBA,GAAsB,WAEvB,SAAUnE,MAGhByB,GAAWzB,EAAKyB,SAASxE,oBACR,UAAbwE,KAA0BzB,EAAKkS,SAA0B,WAAbzQ,KAA2BzB,EAAKmS,mBAGzE,SAAUnS,SAGhBA,GAAKmC,cACJA,WAAWiQ,cAGVpS,EAAKmS,YAAa,SAIjB,SAAUnS,OAKZA,EAAOA,EAAKiQ,WAAYjQ,EAAMA,EAAOA,EAAKgE,eAC1ChE,EAAKO,SAAW,SACb,SAGF,UAGE,SAAUP,UACX6C,EAAK2I,QAAL,MAAuBxL,WAItB,SAAUA,SACZkM,IAAQ1K,KAAMxB,EAAKyB,iBAGlB,SAAUzB,SACXiM,IAAQzK,KAAMxB,EAAKyB,kBAGjB,SAAUzB,MACf5B,GAAO4B,EAAKyB,SAASxE,oBACT,UAATmB,GAAkC,WAAd4B,EAAKvD,MAA8B,WAAT2B,QAG9C,SAAU4B,MACboP,SACmC,UAAhCpP,EAAKyB,SAASxE,eACN,SAAd+C,EAAKvD,OAImC,OAArC2S,EAAOpP,EAAKd,aAAa,UAA2C,SAAvBkQ,EAAKnS,sBAI9CsH,EAAuB,kBACtB,UAGFA,EAAuB,SAAUG,EAAc3G,UAC7CA,EAAS,QAGbwG,EAAuB,SAAUG,EAAc3G,EAAQyG,UACnDA,EAAW,EAAIA,EAAWzG,EAASyG,UAGrCD,EAAuB,SAAUG,EAAc3G,UAClDE,GAAI,EACAA,EAAIF,EAAQE,GAAK,IACX8C,KAAM9C,SAEbyG,SAGDH,EAAuB,SAAUG,EAAc3G,UACjDE,GAAI,EACAA,EAAIF,EAAQE,GAAK,IACX8C,KAAM9C,SAEbyG,QAGFH,EAAuB,SAAUG,EAAc3G,EAAQyG,UACxDvG,GAAIuG,EAAW,EAAIA,EAAWzG,EAASyG,IACjCvG,GAAK,KACD8C,KAAM9C,SAEbyG,QAGFH,EAAuB,SAAUG,EAAc3G,EAAQyG,UACxDvG,GAAIuG,EAAW,EAAIA,EAAWzG,EAASyG,IACjCvG,EAAIF,KACAgD,KAAM9C,SAEbyG,OAKV7B,EAAK2I,QAAL,IAAsB3I,EAAK2I,QAAL,EAGtB,KAAMvN,KAAOoU,OAAO,EAAMC,UAAU,EAAMC,MAAM,EAAMC,UAAU,EAAMC,OAAO,KACvEjH,QAASvN,GAAMgG,EAAmBhG,EAExC,KAAMA,KAAOyU,QAAQ,EAAMC,OAAO,KAC5BnH,QAASvN,GAAMiG,EAAoBjG,EAKzC0G,GAAWhF,UAAYkD,EAAK+P,QAAU/P,EAAK2I,QAC3C3I,EAAK8B,WAAa,GAAIA,GAEtB7C,EAAWlC,EAAOkC,SAAW,SAAU1C,EAAUyT,MAC5CrB,GAAStR,EAAO0E,EAAQnI,EAC3BqW,EAAO3S,EAAQ4S,EACfC,EAAShI,GAAY5L,EAAW,QAE5B4T,QACGH,GAAY,EAAIG,EAAOhL,MAAO,SAG9B5I,SAEKyD,EAAK6D,UAEVoM,GAAQ,CAGTtB,KAAYtR,EAAQyL,GAAO/K,KAAMkS,MACjC5S,MAEI4S,EAAM9K,MAAO9H,EAAM,GAAGnC,SAAY+U,KAEpC/R,KAAO6D,UAGL,GAGJ1E,EAAQ0L,GAAahL,KAAMkS,QACtB5S,EAAM6C,UACThC,YACCyQ,OAEDtR,EAAM,GAAG1D,QAASD,GAAO,SAExBuW,EAAM9K,MAAOwJ,EAAQzT,aAIxBtB,IAAQoG,GAAKyD,SACZpG,EAAQ8L,GAAWvP,GAAOmE,KAAMkS,KAAcC,EAAYtW,MAC9DyD,EAAQ6S,EAAYtW,GAAQyD,QACnBA,EAAM6C,UACThC,YACCyQ,OACD/U,UACGyD,MAEF4S,EAAM9K,MAAOwJ,EAAQzT,aAIzByT,cAQAqB,GACNC,EAAM/U,OACN+U,EACClT,EAAO6P,MAAOrQ,MAEFA,EAAUe,GAAS6H,MAAO,IA+XzCwC,EAAU5K,EAAO4K,QAAU,SAAUpL,EAAUc,MAC1CjC,GACHmK,KACAD,KACA6K,EAAS1R,GAAelC,EAAW,SAE9B4T,EAAS,KAER9S,MACG4B,EAAU1C,MAEfc,EAAMnC,OACFE,OACEsJ,EAAmBrH,EAAMjC,IAC7B+U,EAAQnR,KACAd,KAAMiS,KAEFjS,KAAMiS,KAKf1R,GAAelC,EAAU8I,EAA0BC,EAAiBC,MAGtEhJ,SAAWA,QAEZ4T,IAYRzQ,EAAS3C,EAAO2C,OAAS,SAAUnD,EAAUC,EAASQ,EAASC,MAC1D7B,GAAG2G,EAAQqO,EAAOxW,EAAMiD,EAC3BwT,EAA+B,kBAAb9T,IAA2BA,EAC7Cc,GAASJ,GAAQgC,EAAW1C,EAAW8T,EAAS9T,UAAYA,QAEnDS,MAIY,IAAjBK,EAAMnC,OAAe,MAGhBmC,EAAM,GAAKA,EAAM,GAAG8H,MAAO,GAC/BpD,EAAO7G,OAAS,GAAkC,QAA5BkV,EAAQrO,EAAO,IAAInI,MACvB,IAArB4C,EAAQkB,UAAkBG,GAAkBmC,EAAK6E,SAAU9C,EAAO,GAAGnI,MAAS,OAEnEoG,EAAKnD,KAAL,GAAiBuT,EAAMxO,QAAQ,GAAGjI,QAAQ4P,GAAWC,IAAYhN,QAAkB,IACzFA,QACEQ,EAGIqT,OACD7T,EAAQ8C,cAGR/C,EAAS4I,MAAOpD,EAAO7B,QAAQJ,MAAM5E,cAI7CiO,GAAA,aAA0BxK,KAAMpC,GAAa,EAAIwF,EAAO7G,OACpDE,QACC2G,EAAO3G,IAGV4E,EAAK6E,SAAWjL,EAAOwW,EAAMxW,YAG5BiD,EAAOmD,EAAKnD,KAAMjD,MAEjBqD,EAAOJ,EACZuT,EAAMxO,QAAQ,GAAGjI,QAAS4P,GAAWC,IACrCpK,GAAST,KAAMoD,EAAO,GAAGnI,OAAUyF,EAAa7C,EAAQ8C,aAAgB9C,IACpE,MAGGiI,OAAQrJ,EAAG,KACP6B,EAAK/B,QAAUgE,EAAY6C,IAChCxF,YACA6B,MAAOpB,EAASC,GACdD,gBAWVqT,GAAY1I,EAASpL,EAAUc,IAChCJ,EACAT,GACCqB,EACDb,GACCR,GAAW4C,GAAST,KAAMpC,IAAc8C,EAAa7C,EAAQ8C,aAAgB9C,GAExEQ,GAMRsB,EAAQ2O,WAAajO,EAAQ9E,MAAM,IAAIgT,KAAM9E,IAAYjJ,KAAK,MAAQH,EAItEV,EAAQ0O,mBAAqBnF,EAG7BC,IAIAxJ,EAAQ0N,aAAe5L,EAAO,SAAUhE,SAEmC,GAAnEA,EAAGwP,wBAAyBhO,EAASyC,cAAc,eAMrDD,EAAO,SAAUhE,YACnBgP,UAAY,mBAC+B,MAAvChP,EAAGgR,WAAW/Q,aAAa,aAEvB,yBAA0B,SAAUc,EAAM5B,EAAMmM,OACpDA,QACEvK,GAAKd,aAAcd,EAA6B,SAAvBA,EAAKnB,cAA2B,EAAI,KAOjEkE,EAAQoK,YAAetI,EAAO,SAAUhE,YAC1CgP,UAAY,aACZgC,WAAWrO,aAAc,QAAS,IACY,KAA1C3C,EAAGgR,WAAW/Q,aAAc,cAExB,QAAS,SAAUc,EAAM5B,EAAMmM,OACnCA,GAAyC,UAAhCvK,EAAKyB,SAASxE,oBACrB+C,GAAKmT,eAOTlQ,EAAO,SAAUhE,SACgB,OAA/BA,EAAGC,aAAa,iBAEZkM,GAAU,SAAUpL,EAAM5B,EAAMmM,MACtC8E,OACE9E,QACEvK,GAAM5B,MAAW,EAAOA,EAAKnB,eACjCoS,EAAMrP,EAAK8N,iBAAkB1P,KAAWiR,EAAIC,UAC7CD,EAAI1M,MACL,MAMJ,IAAIyQ,IAAUjJ,OAAOvK,MAErBA,GAAOyT,WAAa,iBACdlJ,QAAOvK,SAAWA,WACfA,OAASwT,IAGVxT,GE3sERL,EAAKJ,GACL8J,EAAW9J"}